{"version":3,"sources":["../../../../../../src/app/products/%5Bslug%5D/ProductPageWrapper.tsx/__nextjs-internal-proxy.mjs","../../../../../../src/app/products/%5Bslug%5D/page.tsx","../../../../../../src/lib/queries.ts"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/src/app/products/[slug]/ProductPageWrapper.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/src/app/products/[slug]/ProductPageWrapper.tsx\",\n    \"default\",\n);\n","import type { Metadata } from 'next';\nimport { db } from '@/lib/firebase';\nimport { collection, query, where, getDocs } from 'firebase/firestore';\nimport { fetchReviews } from '@/lib/fetch-products';\nimport { getProductBySlug } from '@/lib/queries';\nimport ProductPageWrapper from './ProductPageWrapper';\n\nexport async function generateMetadata({ params }: { params: Promise<{ slug: string }> }): Promise<Metadata> {\n  const { slug } = await params;\n\n  try {\n    const q = query(collection(db, 'products'), where('slug', '==', slug));\n    const snap = await getDocs(q);\n\n    if (!snap.empty) {\n      const product = snap.docs[0].data();\n      return {\n        title: `${product.title} | DYMNDS`,\n        description: `${product.title} — Premium athletic wear by DYMNDS. 10% of your purchase funds survivor healing.`,\n        openGraph: {\n          title: `${product.title} | DYMNDS`,\n          description: `${product.title} — Premium athletic wear by DYMNDS.`,\n          images: product.images?.[0] ? [{ url: product.images[0], width: 1200, height: 630, alt: product.title }] : [],\n        },\n      };\n    }\n  } catch (error) {\n    console.error('Error generating metadata:', error);\n  }\n\n  return {\n    title: 'Product | DYMNDS',\n    description: 'Premium athletic wear by DYMNDS. 10% of your purchase funds survivor healing.',\n  };\n}\n\n/**\n * Fix #3/#4: All data now fetched server-side in parallel.\n * Reviews + matching product no longer trigger client-side Firestore waterfalls.\n * This eliminates ~150KB of Firebase client SDK from the product page bundle.\n */\nexport default async function ProductPage({ params }: { params: Promise<{ slug: string }> }) {\n  const { slug } = await params;\n\n  // Fetch product server-side (reuses the same query from generateMetadata via Next.js dedup)\n  let initialProduct: Record<string, unknown> | null = null;\n  try {\n    const q = query(collection(db, 'products'), where('slug', '==', slug));\n    const snap = await getDocs(q);\n    if (!snap.empty) {\n      const doc = snap.docs[0];\n      initialProduct = { id: doc.id, ...doc.data() };\n    }\n  } catch (error) {\n    console.error('Error fetching product:', error);\n  }\n\n  // Fetch reviews + matching product in parallel (server-side, no client JS needed)\n  const matchingSlug = initialProduct?.matchingSetSlug as string | undefined;\n  const [reviews, matchingProduct] = await Promise.all([\n    fetchReviews(slug),\n    matchingSlug ? getProductBySlug(matchingSlug) : Promise.resolve(null),\n  ]);\n\n  return (\n    <ProductPageWrapper\n      initialProduct={initialProduct}\n      initialReviews={reviews}\n      initialMatchingProduct={matchingProduct}\n    />\n  );\n}\n","import { db } from '@/lib/firebase';\nimport { collection, query, where, getDocs, limit, orderBy, QueryConstraint } from 'firebase/firestore';\nimport type { Product } from '@/lib/firebase';\nimport { safeParseProduct } from '@/lib/schemas';\n\n/**\n * Shared Firebase queries for products.\n * Single source of truth for common product fetching patterns.\n */\n\nexport async function getProductBySlug(slug: string): Promise<Product | null> {\n  const q = query(collection(db, 'products'), where('slug', '==', slug), limit(1));\n  const snap = await getDocs(q);\n  if (snap.empty) return null;\n  return safeParseProduct({ id: snap.docs[0].id, ...snap.docs[0].data() }) as Product | null;\n}\n\nexport async function getProductsByCategory(category: 'Men' | 'Women'): Promise<Product[]> {\n  const q = query(\n    collection(db, 'products'),\n    where('category', '==', category),\n    where('is_active', '==', true),\n    orderBy('displayOrder', 'asc')\n  );\n  const snap = await getDocs(q);\n  return snap.docs.map(doc => safeParseProduct({ id: doc.id, ...doc.data() }) as Product | null).filter((p): p is Product => p !== null);\n}\n\nexport async function getFeaturedProducts(category?: 'Men' | 'Women'): Promise<Product[]> {\n  const constraints: QueryConstraint[] = [\n    where('featured', '==', true),\n    where('is_active', '==', true),\n  ];\n  if (category) constraints.push(where('category', '==', category));\n\n  const q = query(collection(db, 'products'), ...constraints);\n  const snap = await getDocs(q);\n  return snap.docs.map(doc => safeParseProduct({ id: doc.id, ...doc.data() }) as Product | null).filter((p): p is Product => p !== null);\n}\n\nexport async function getMatchingProduct(matchingSetSlug: string): Promise<Product | null> {\n  return getProductBySlug(matchingSetSlug);\n}\n"],"names":[],"mappings":"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","ignoreList":[0]}