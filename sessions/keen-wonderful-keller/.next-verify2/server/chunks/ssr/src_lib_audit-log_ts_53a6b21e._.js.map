{"version":3,"sources":["../../../../../../src/lib/audit-log.ts","../../../../../../src/lib/logger.ts"],"sourcesContent":["import { collection, addDoc, serverTimestamp } from 'firebase/firestore';\nimport { db } from '@/lib/firebase';\nimport { logger } from '@/lib/logger';\n\nexport type AuditAction =\n  | 'order_status_updated'\n  | 'order_deleted'\n  | 'product_created'\n  | 'product_updated'\n  | 'product_deleted'\n  | 'discount_created'\n  | 'discount_updated'\n  | 'discount_deleted'\n  | 'customer_note_saved'\n  | 'inventory_adjusted'\n  | 'expense_created'\n  | 'expense_deleted'\n  | 'bulk_delete'\n  | 'message_deleted'\n  | 'waitlist_exported';\n\ninterface AuditDetails {\n  [key: string]: string | number | boolean | undefined;\n}\n\n/**\n * Logs an admin action to the admin_audit_log collection.\n * Non-blocking â€” fires and forgets so it never blocks UI actions.\n */\nexport function logAdminAction(\n  action: AuditAction,\n  details: AuditDetails,\n  adminEmail?: string\n): void {\n  addDoc(collection(db, 'admin_audit_log'), {\n    action,\n    details,\n    admin_email: adminEmail || 'unknown',\n    timestamp: serverTimestamp(),\n    created_at: new Date().toISOString(),\n  }).catch((error) => {\n    logger.error('Audit log write failed', { action }, error);\n  });\n}\n","/**\n * Structured JSON logger for production observability [INF-106].\n *\n * Outputs structured JSON to stdout/stderr for Vercel Logs ingestion.\n * Vercel automatically parses JSON log lines into searchable, filterable fields.\n *\n * Usage:\n *   import { logger } from '@/lib/logger';\n *   logger.info('Order created', { orderId: '123', total: 99.99 });\n *   logger.error('Payment failed', { orderId: '123' }, error);\n */\n\ntype LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  context?: Record<string, unknown>;\n  error?: {\n    name: string;\n    message: string;\n    stack?: string;\n  };\n}\n\n// PII fields to mask in log output\nconst PII_FIELDS = new Set(['email', 'customer_email', 'customerEmail', 'phone', 'password', 'token', 'idToken', 'creditCard', 'ssn']);\n\nfunction maskPII(context: Record<string, unknown>): Record<string, unknown> {\n  const masked = { ...context };\n  for (const [key, value] of Object.entries(masked)) {\n    if (typeof value === 'string' && PII_FIELDS.has(key)) {\n      // Show first 3 chars + mask remainder\n      masked[key] = value.length > 3 ? value.slice(0, 3) + '***' : '***';\n    } else if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n      masked[key] = maskPII(value as Record<string, unknown>);\n    }\n  }\n  return masked;\n}\n\nfunction createLogEntry(\n  level: LogLevel,\n  message: string,\n  context?: Record<string, unknown>,\n  error?: unknown\n): LogEntry {\n  const entry: LogEntry = {\n    level,\n    message,\n    timestamp: new Date().toISOString(),\n  };\n\n  if (context && Object.keys(context).length > 0) {\n    entry.context = maskPII(context);\n  }\n\n  if (error instanceof Error) {\n    entry.error = {\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n    };\n  } else if (error) {\n    entry.error = {\n      name: 'UnknownError',\n      message: String(error),\n    };\n  }\n\n  return entry;\n}\n\nfunction emit(entry: LogEntry): void {\n  const json = JSON.stringify(entry);\n\n  if (entry.level === 'error' || entry.level === 'warn') {\n    console.error(json);\n  } else {\n    console.log(json);\n  }\n}\n\nexport const logger = {\n  debug(message: string, context?: Record<string, unknown>): void {\n    if (process.env.NODE_ENV === 'development') {\n      emit(createLogEntry('debug', message, context));\n    }\n  },\n\n  info(message: string, context?: Record<string, unknown>): void {\n    emit(createLogEntry('info', message, context));\n  },\n\n  warn(message: string, context?: Record<string, unknown>, error?: unknown): void {\n    emit(createLogEntry('warn', message, context, error));\n  },\n\n  error(message: string, context?: Record<string, unknown>, error?: unknown): void {\n    emit(createLogEntry('error', message, context, error));\n  },\n};\n"],"names":[],"mappings":"uCAAA,EAAA,CAAA,CAAA,OAAA,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OC0BA,IAAM,EAAa,IAAI,IAAI,CAAC,QAAS,iBAAkB,gBAAiB,QAAS,WAAY,QAAS,UAAW,aAAc,MAAM,EAerI,SAAS,EACP,CAAe,CACf,CAAe,CACf,CAAiC,CACjC,CAAe,EAEf,IAAM,EAAkB,OACtB,UACA,EACA,UAAW,IAAI,OAAO,WAAW,EACnC,EAmBA,OAjBI,GAAW,OAAO,IAAI,CAAC,GAAS,MAAM,CAAG,GAAG,CAC9C,EAAM,OAAO,CAAG,AA1BpB,SAAS,EAAQ,CAAgC,EAC/C,IAAM,EAAS,CAAE,GAAG,CAAO,AAAC,EAC5B,IAAK,GAAM,CAAC,EAAK,EAAM,GAAI,OAAO,OAAO,CAAC,GACnB,KAD4B,KAC7C,OAAO,GAAsB,EAAW,GAAG,CAAC,GAE9C,CAAM,CAAC,CAF6C,CAEzC,CAAG,EAAM,MAAM,CAAG,EAAI,EAAM,KAAK,CAAC,EAAG,GAAK,MAAQ,MACnC,UAAjB,OAAO,GAAgC,OAAV,CAAkB,EAAC,MAAM,OAAO,CAAC,IACvE,EAAM,CAAC,CADwE,CACpE,CAAG,EAAQ,EAAA,EAG1B,OAAO,CACT,EAe4B,EAAA,EAGtB,aAAiB,MACnB,CAD0B,CACpB,KAAK,CAAG,CACZ,KAAM,EAAM,IAAI,CAChB,QAAS,EAAM,OAAO,CACtB,MAAO,EAAM,KAAK,AACpB,EACS,IACT,EAAM,CADU,IACL,CAAG,CACZ,KAAM,eACN,QAAS,OAAO,GAClB,EAGK,CACT,CAEA,SAAS,EAAK,CAAe,EAC3B,IAAM,EAAO,KAAK,SAAS,CAAC,EAExB,CAAgB,YAAV,KAAK,EAAgC,QAAQ,CAAxB,EAAM,KAAK,CACxC,QAAQ,KAAK,CAAC,GAEd,QAAQ,GAAG,CAAC,EAEhB,CAEO,IAAM,EAAS,CACpB,MAAM,CAAe,CAAE,CAAiC,EAIxD,EAEA,KAAK,CAAe,CAAE,CAAiC,EACrD,EAAK,EAAe,OAAQ,EAAS,GACvC,EAEA,KAAK,CAAe,CAAE,CAAiC,CAAE,CAAe,EACtE,EAAK,EAAe,OAAQ,EAAS,EAAS,GAChD,EAEA,MAAM,CAAe,CAAE,CAAiC,CAAE,CAAe,EACvE,EAAK,EAAe,QAAS,EAAS,EAAS,GACjD,CACF,EDzEO,SAAS,EACd,CAAmB,CACnB,CAAqB,CACrB,CAAmB,EAEnB,CAAA,EAAA,EAAA,MAAA,AAAM,EAAC,CAAA,EAAA,EAAA,UAAA,AAAU,EAAC,EAAA,EAAE,CAAE,mBAAoB,QACxC,UACA,EACA,YAAa,GAAc,UAC3B,UAAW,CAAA,EAAA,EAAA,eAAA,AAAe,IAC1B,WAAY,IAAI,OAAO,WAAW,EACpC,GAAG,KAAK,CAAC,AAAC,IACR,EAAO,KAAK,CAAC,yBAA0B,QAAE,CAAO,EAAG,EACrD,EACF"}